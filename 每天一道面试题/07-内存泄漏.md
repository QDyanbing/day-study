# 内存泄漏 虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏
  意外的全局变量引起的内存泄漏
    function fn () {  
        fn1 = 'xxxxxx';//fn 成为一个全局变量，不会被回收
    }
    原因：全局变量不会被回收
    解决：使用严格模式(因为严格模式定义的变量都有其单独的作用域)  
  闭包引起的内存泄漏
    var fn = (function(){  
      var fn1 = 'xxxxxx'; // 被闭包所引用，不会被回收
      return function(){
        console.log(fn1);
      }
    })()
    原因：闭包可以维持函数内部局部变量，使其得不到释放
    解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对DOM的引用
  DOM清空或删除时，事件未清除导致的内存泄漏
    原因：虽然DOM被清空或者删除了，但是对象中还存在对DOM的引用
    解决一：zepto 和 原生 js 下，#container dom 元素，还在内存里 jquery 的 empty 和 remove 会帮助开发者避免这个问题
    解决二：手动删除
  子元素存在引用引起的内存泄漏
    原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom
    解决：手动删除定时器
      
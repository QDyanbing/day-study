# 事件循环机制
  一、为什么会有Event Loop
    JavaScript的任务分为两种同步和异步，它们的处理方式也各自不同，同步任务是直接放在主线程.上排队依次执行，异步任务会放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到调用栈然后主线程执行调用栈的任务。
    调用栈:调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上”下文信息，函数执行完后，它的执行上下文会从栈中弹出。
    JavaScript是单线程的，单线程是指js引擎中解析和执行 js代码的线程只有一个(主线程)，每次只能做一件事情,然而ajax请求中，主线程在等待响应的过程中回去做其他事情，浏览器先在事件表注册ajax的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说js处理ajax请求的方式是异步的。
    综上所述，检查调用栈是否为空以及讲某个任务添加到调用 栈中的个过程就是event loop，这就是JavaScript实现异步的核心。
  二、宏任务和微任务 ES6 规范中，microtask 称为 jobs，macrotask 称为 task宏任务是由宿主发起的，而微任务由JavaScript自身发起。
    宏任务:常见的定时器,用户交互事件等等.setTimeout/setInterval,UI rendering/UI事件
    微任务:MutaionObserver,Promise;
    执行顺序:
      万物皆从全局上下文准备退出，全局的同步代码运行结束的这个时机开始;
      同一层级下微任务永远比宏任务先执行;即Promise.then比setTimeout先执行;
      每个宏任务,都单独关联了一个微任务队列
      每个层级的宏任务,都对应了他们的微任务队列,微任务队列遵循先进先出的原则,当全局同步代码执行完毕后,就开始执行第一层的任务。同层级的微任务永远先于宏任务执行,并且会在当前层级宏任务结束前全部执行完毕; 
  三、Event Loop的过程
    执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；
    检查是否存在微任务，有则会执行至微任务队列为空；
    如果宿主为浏览器，可能会渲染页面；
    开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。





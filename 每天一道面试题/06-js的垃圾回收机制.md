# js的垃圾回收机制  Js具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。
  垃圾回收机制
    JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码在执行环境过程中使用的内存。
    垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性的执行这一操作。
  垃圾回收机制的作用
    1.将某个不再被使用的变量所占用的内存释放掉，是为了不让内存总是被消耗而被没有释放，导致整个系统无法支持更为庞大的运算
    2.垃圾回收机制不是总是那么高效，其不是总在运行，因此有时需要我们人为的释放被占用的内存，从而使程序能够支持更为庞大的运算，能够接受更为巨量的数据运算。
  垃圾回收机制的原理
    找出那些不再继续使用的变量，然后释放其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行；
    垃圾回收机制的标记策略
      垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：标记清除、引用计数。
      标记清除
        当变量进入环境时，将其标记为“进入环境”，当变量离开环境时，将其标记为“离开环境”（常用）
        某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量
        到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同
      引用计数 跟踪记录每个值被引用的次数
        当声明一个变量a并将一个引用类型的值赋给该变量时，这个值引用次数就是1
        如果同一个引用类型的值又被赋给另一个变量b，则该值的引用次数加1，相反，如果包含这个值引用的变量a又取得了另一个值（也就是前面的引用被覆盖，不再引用前面那个值），则这个值的引用次数减1。
        当这个值的引用次数变成0时，则说明没有办法再访问这个值，因而就可以将其占用的内存空间回收回来
        少见，几乎不用，除了早版IE的元素JS，因为会出现循环引用的问题
  堆和栈
    堆和栈空间分配区别：
      栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
      堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表
    堆和栈空间存放数据类型的区别：
      栈：基本类型是：Undefined/Null/Boolean/Number/String，基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本
      堆：引用类型：object，Array，function等，引用类型的值是对象类型，保存在堆内存中包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
      js操作对象就是在操作对象的引用，而不是在操作实际的对象
    堆和栈缓存方式区别：
      栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放
      堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些
    堆和栈数据结构区别：
      堆（数据结构）：堆可以被看成是一棵树，如：堆排序
      栈（数据结构）：一种先进后出的数据结构
  内存管理
    垃圾回收器是周期运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。触发方式的改善很重要
    虽然说使用具备垃圾回收机制的语言写程序，开发人员一般不必操心内存管理的问题。但是JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同的，其中最主要的问题之一，就是出于对安全方面考虑，防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃，所以分配给Web浏览器的内存数量通常比分配给桌面应用的程序少











  当一个变量的生命周期结束之后它所指向的内存就应该被释放。
  JS有两种变量，全局变量和在函数中产生的局部变量。
  局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。
  JS执行环境中的垃圾回收器怎样才能检测哪块内存可以被回收有两种方式：
    标记清除（mark and sweep）
      大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。垃圾收集器给内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上的标记的变量即为需要回收的变量，因为环境中的变量已经无法访问到这些变量。
    引用计数(reference counting)
      这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。
  可达性
    简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。
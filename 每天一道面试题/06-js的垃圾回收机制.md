# js的垃圾回收机制  Js具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。
  垃圾回收机制
    JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码在执行环境过程中使用的内存。
    垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性的执行这一操作。
  垃圾回收机制的作用
    1.将某个不再被使用的变量所占用的内存释放掉，是为了不让内存总是被消耗而被没有释放，导致整个系统无法支持更为庞大的运算
    2.垃圾回收机制不是总是那么高效，其不是总在运行，因此有时需要我们人为的释放被占用的内存，从而使程序能够支持更为庞大的运算，能够接受更为巨量的数据运算。
  垃圾回收机制的原理
    找出那些不再继续使用的变量，然后释放其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行；
    垃圾回收机制的标记策略
      垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：标记清除、引用计数。
      标记清除
        当变量进入环境时，将其标记为“进入环境”，当变量离开环境时，将其标记为“离开环境”（常用）
        某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量
        到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同
      引用计数 跟踪记录每个值被引用的次数
        当声明一个变量a并将一个引用类型的值赋给该变量时，这个值引用次数就是1
        如果同一个引用类型的值又被赋给另一个变量b，则该值的引用次数加1，相反，如果包含这个值引用的变量a又取得了另一个值（也就是前面的引用被覆盖，不再引用前面那个值），则这个值的引用次数减1。
        当这个值的引用次数变成0时，则说明没有办法再访问这个值，因而就可以将其占用的内存空间回收回来
        少见，几乎不用，除了早版IE的元素JS，因为会出现循环引用的问题
  堆和栈
    堆和栈空间分配区别：
      栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
      堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表
    堆和栈空间存放数据类型的区别：
      栈：基本类型是：Undefined/Null/Boolean/Number/String，基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本
      堆：引用类型：object，Array，function等，引用类型的值是对象类型，保存在堆内存中包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
      js操作对象就是在操作对象的引用，而不是在操作实际的对象
    堆和栈缓存方式区别：
      栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放
      堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些
    堆和栈数据结构区别：
      堆（数据结构）：堆可以被看成是一棵树，如：堆排序
      栈（数据结构）：一种先进后出的数据结构
  内存管理
    垃圾回收器是周期运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。触发方式的改善很重要
    虽然说使用具备垃圾回收机制的语言写程序，开发人员一般不必操心内存管理的问题。但是JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同的，其中最主要的问题之一，就是出于对安全方面考虑，防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃，所以分配给Web浏览器的内存数量通常比分配给桌面应用的程序少